<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="EdgarDing Blog">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="http://www.edgarding.cn/img/home-bg-main.jpg">
    <meta property="twitter:image" content="http://www.edgarding.cn/img/home-bg-main.jpg" />
    

    
    <meta name="title" content="Spring核心概念梳理" />
    <meta property="og:title" content="Spring核心概念梳理" />
    <meta property="twitter:title" content="Spring核心概念梳理" />
    

    
    <meta name="description" content="一天又一天">
    <meta property="og:description" content="一天又一天" />
    <meta property="twitter:description" content="一天又一天" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="Edgarding, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>Spring核心概念梳理 | EdgarDing 的博客 | One day One day</title>

    <link rel="canonical" href="/post/2021/spring%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E6%A2%B3%E7%90%86-spring-he-xin-gai-nian-shu-li/">

    
    
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link href="https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.1/css/all.css" rel="stylesheet" type="text/css">

    
    

    
    <script src="/js/jquery.min.js"></script>

    
    <script src="/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    

</head>




<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">EdgarDing Blog</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                        
                        <li>
                            <a href="/categories/%E7%AE%97%E6%B3%95">算法</a>
                        </li>
                        
                    
                    
		    
                        <li><a href="/top/archive/">ARCHIVE</a></li>
                    
                        <li><a href="/top/about/">ABOUT</a></li>
                    

                    
		    <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		    </li>
                    
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/home-bg-main.jpg')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/spring" title="Spring">
                            Spring
                        </a>
                        
                    </div>
                    <h1>Spring核心概念梳理</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                    EdgarDing Blog
                             
                            on 
                            Monday, February 28, 2022
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <h1 id="spring核心概念梳理">Spring核心概念梳理</h1>
<h2 id="introduction">Introduction</h2>
<p>针对Spring的几个核心概念进行梳理。</p>
<ul>
<li>SpringBoot框架的启动流程与相应注解。</li>
<li>IOC与AOP两大Spring容器的核心功能和相应注解。</li>
<li>Spring相应注解。</li>
<li>Spring相应问题。</li>
</ul>
<p>IOC与AOP理解简述：</p>
<blockquote>
<p>IOC 叫做控制反转，指的是通过Spring来管理对象的创建、配置和生命周期，这样相当于把控制权交给了Spring，不需要人工来管理对象之间复杂的依赖关系，这样做的好处就是解耦。在Spring里面，主要提供了 BeanFactory 和 ApplicationContext 两种 IOC 容器，通过他们来实现对 Bean 的管理。</p>
<p>AOP 叫做面向切面编程，他是一个编程范式，目的就是提高代码的模块性。Srping AOP 基于动态代理的方式实现，如果是实现了接口的话就会使用 JDK 动态代理，反之则使用 CGLIB 代理，Spring中 AOP 的应用主要体现在 事务、日志、异常处理等方面，通过在代码的前后做一些增强处理，可以实现对业务逻辑的隔离，提高代码的模块化能力，同时也是解耦。Spring主要提供了 Aspect 切面、JoinPoint 连接点、PointCut 切入点、Advice 增强等实现方式。</p>
</blockquote>
<h2 id="spring-boot">Spring Boot</h2>
<h3 id="简介">简介</h3>
<p><em>这里谈论的Spring Boot基于官方version2.6.4 doc</em></p>
<blockquote>
<p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can &ldquo;just run&rdquo;.</p>
<p>即Spring Boot就是为了更方便去构建Spring应用。</p>
</blockquote>
<p><strong>Features</strong></p>
<ul>
<li>Create stand-alone Spring applications</li>
<li>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</li>
<li>Provide opinionated &lsquo;starter&rsquo; dependencies to simplify your build configuration</li>
<li>Automatically configure Spring and 3rd party libraries whenever possible</li>
<li>Provide production-ready features such as metrics, health checks, and externalized configuration</li>
<li>Absolutely no code generation and no requirement for XML configuration</li>
</ul>
<h3 id="springboot的启动">SpringBoot的启动</h3>
<p>Spring Boot项目在主类<code>main()</code>方法，通过<code>SpringApplication.run(XXApplication.class, args);</code>仅可以完成项目的启动，该节追溯该SpringApplication和run()的底层，探寻启动流程。</p>
<p><code>SpringApplication</code>属于SpringBoot的本身产物，封装了对Spring的启动。</p>
<p>SpringApplication实例化代码：(构造函数)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#50fa7b">SpringApplication</span><span style="color:#ff79c6">(</span>ResourceLoader resourceLoader<span style="color:#ff79c6">,</span> Class<span style="color:#ff79c6">&lt;?&gt;...</span> primarySources<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">sources</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> LinkedHashSet<span style="color:#ff79c6">();</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">bannerMode</span> <span style="color:#ff79c6">=</span> Mode<span style="color:#ff79c6">.</span><span style="color:#50fa7b">CONSOLE</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">logStartupInfo</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">addCommandLineProperties</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">addConversionService</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">headless</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">registerShutdownHook</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">additionalProfiles</span> <span style="color:#ff79c6">=</span> Collections<span style="color:#ff79c6">.</span><span style="color:#50fa7b">emptySet</span><span style="color:#ff79c6">();</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">isCustomEnvironment</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">false</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">lazyInitialization</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">false</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">applicationContextFactory</span> <span style="color:#ff79c6">=</span> ApplicationContextFactory<span style="color:#ff79c6">.</span><span style="color:#50fa7b">DEFAULT</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">applicationStartup</span> <span style="color:#ff79c6">=</span> ApplicationStartup<span style="color:#ff79c6">.</span><span style="color:#50fa7b">DEFAULT</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">resourceLoader</span> <span style="color:#ff79c6">=</span> resourceLoader<span style="color:#ff79c6">;</span>
        Assert<span style="color:#ff79c6">.</span><span style="color:#50fa7b">notNull</span><span style="color:#ff79c6">(</span>primarySources<span style="color:#ff79c6">,</span> <span style="color:#f1fa8c">&#34;PrimarySources must not be null&#34;</span><span style="color:#ff79c6">);</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">primarySources</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> LinkedHashSet<span style="color:#ff79c6">(</span>Arrays<span style="color:#ff79c6">.</span><span style="color:#50fa7b">asList</span><span style="color:#ff79c6">(</span>primarySources<span style="color:#ff79c6">));</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">webApplicationType</span> <span style="color:#ff79c6">=</span> WebApplicationType<span style="color:#ff79c6">.</span><span style="color:#50fa7b">deduceFromClasspath</span><span style="color:#ff79c6">();</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">bootstrapRegistryInitializers</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">getBootstrapRegistryInitializersFromSpringFactories</span><span style="color:#ff79c6">();</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">setInitializers</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">getSpringFactoriesInstances</span><span style="color:#ff79c6">(</span>ApplicationContextInitializer<span style="color:#ff79c6">.</span><span style="color:#50fa7b">class</span><span style="color:#ff79c6">));</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">setListeners</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">getSpringFactoriesInstances</span><span style="color:#ff79c6">(</span>ApplicationListener<span style="color:#ff79c6">.</span><span style="color:#50fa7b">class</span><span style="color:#ff79c6">));</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">mainApplicationClass</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">deduceMainApplicationClass</span><span style="color:#ff79c6">();</span>
    <span style="color:#ff79c6">}</span>
</code></pre></div><ul>
<li>webApplicationType：推断应用类型，通过classpath来推断当前项目使用的是哪一种类型
WebApplicationType.NONE，WebApplicationType.SERVLET，WebApplicationType.REACTIVE。</li>
<li>bootstrapRegistryInitializers引导程序注册的初始化器：初始化bootstrapRegistryInitializers引导程序注册的初始化器，从<code>META-INF/spring.factories</code>配置文件中，获取Bootstrapper.class和BootstrapRegistryInitializer.class这两个配置类型，然后合并存储在bootstrapRegistryInitializers中。</li>
<li><code>this.Initializers()</code>应用上下文初始化器：使用<code>SpringFactoriesLoader</code>查找并加载<code>classpath:META-INF/spring.factories</code>文件中所有可用的 <code>ApplicationContextInitializer</code>。</li>
<li><code>this.setListerners()</code>： 使用<code>SpringFactoriesLoader</code>查找并加载<code>classpath下META-INF/spring.factories</code>文件中的所有可用的 <code>ApplicationListener</code>。</li>
<li>mainApplication：推断并设置<code>main()</code>方法的定义类。</li>
</ul>
<p>步骤精简如下：</p>
<ol>
<li>通过 <code>SpringFactoriesLoader</code> 加载 <code>META-INF/spring.factories</code> 文件，获取并创建 <code>SpringApplicationRunListener</code> 对象</li>
<li>然后由 <code>SpringApplicationRunListener</code> 来发出 <code>starting</code> 消息</li>
<li>创建参数，并配置当前 <code>SpringBoot</code> 应用将要使用的 <code>Environment</code></li>
<li>完成之后，依然由 <code>SpringApplicationRunListener</code> 来发出 <code>environmentPrepared</code> 消息</li>
<li>创建 <code>ApplicationContext</code></li>
<li>初始化 <code>ApplicationContext</code>，并设置 <code>Environment</code>，加载相关配置等</li>
<li>由 <code>SpringApplicationRunListener</code> 来发出 <code>contextPrepared</code> 消息，告知Spring Boot 应用使用的 <code>ApplicationContext</code> 已准备OK</li>
<li>将各种 <code>beans</code> 装载入 <code>ApplicationContext</code>，继续由 <code>SpringApplicationRunListener</code> 来发出 <code>contextLoaded</code> 消息，告知 Spring Boot 应用使用的 <code>ApplicationContext</code> 已装填OK</li>
<li><code>refresh ApplicationContext</code>，完成IoC容器可用的最后一步</li>
<li>由 <code>SpringApplicationRunListener</code> 来发出 <code>started</code> 消息</li>
<li>调用<code>callRunners(...)</code>方法，让实现了<code>ApplicationRunner</code>和<code>CommandLineRunner</code>接口类的<code>run</code> 方法得以执行，用于在 Spring 应用上下文准备完毕后，执行一些额外操作。从而完成最终的程序的启动。</li>
<li>由 <code>SpringApplicationRunListener</code> 来发出 <code>running</code> 消息，告知程序已运行起来了</li>
</ol>
<h3 id="springbootapplication注解">@SpringBootApplication注解</h3>
<p>源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Target<span style="color:#ff79c6">(</span>ElementType<span style="color:#ff79c6">.</span><span style="color:#50fa7b">TYPE</span><span style="color:#ff79c6">)</span>
@Retention<span style="color:#ff79c6">(</span>RetentionPolicy<span style="color:#ff79c6">.</span><span style="color:#50fa7b">RUNTIME</span><span style="color:#ff79c6">)</span>
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan<span style="color:#ff79c6">(</span>excludeFilters <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">{</span> @Filter<span style="color:#ff79c6">(</span>type <span style="color:#ff79c6">=</span> FilterType<span style="color:#ff79c6">.</span><span style="color:#50fa7b">CUSTOM</span><span style="color:#ff79c6">,</span> classes <span style="color:#ff79c6">=</span> TypeExcludeFilter<span style="color:#ff79c6">.</span><span style="color:#50fa7b">class</span><span style="color:#ff79c6">),</span>
		@Filter<span style="color:#ff79c6">(</span>type <span style="color:#ff79c6">=</span> FilterType<span style="color:#ff79c6">.</span><span style="color:#50fa7b">CUSTOM</span><span style="color:#ff79c6">,</span> classes <span style="color:#ff79c6">=</span> AutoConfigurationExcludeFilter<span style="color:#ff79c6">.</span><span style="color:#50fa7b">class</span><span style="color:#ff79c6">)</span> <span style="color:#ff79c6">})</span>
<span style="color:#8be9fd;font-style:italic">public</span> @interface SpringBootApplication <span style="color:#ff79c6">{</span> <span style="color:#ff79c6">...</span> <span style="color:#ff79c6">}</span>
</code></pre></div><p>可以很明显的发现这是一个复合注解，其中三个重要的注解为：</p>
<ul>
<li>@SpringBootConfiguration</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan</li>
</ul>
<h4 id="springbootconfiguration">@SpringBootConfiguration</h4>
<p>源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Target<span style="color:#ff79c6">({</span>ElementType<span style="color:#ff79c6">.</span><span style="color:#50fa7b">TYPE</span><span style="color:#ff79c6">})</span>
@Retention<span style="color:#ff79c6">(</span>RetentionPolicy<span style="color:#ff79c6">.</span><span style="color:#50fa7b">RUNTIME</span><span style="color:#ff79c6">)</span>
@Documented
@Configuration
@Indexed
<span style="color:#8be9fd;font-style:italic">public</span> @interface SpringBootConfiguration <span style="color:#ff79c6">{</span>
    @AliasFor<span style="color:#ff79c6">(</span>
        annotation <span style="color:#ff79c6">=</span> Configuration<span style="color:#ff79c6">.</span><span style="color:#50fa7b">class</span>
    <span style="color:#ff79c6">)</span>
    <span style="color:#8be9fd">boolean</span> <span style="color:#50fa7b">proxyBeanMethods</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">default</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
<span style="color:#ff79c6">}</span>

</code></pre></div><p>这里说明<code>@SpringBootConfiguration</code>也是来源于<code>@Configuration</code>，都是将当前累标注为代理类，并将当前累以<code>@Bean</code>注解标记的方法注入到Spring容器中，实例名即为方法名。</p>
<h4 id="enableautoconfiguration">@EnableAutoConfiguration</h4>
<p>源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Target<span style="color:#ff79c6">(</span>ElementType<span style="color:#ff79c6">.</span><span style="color:#50fa7b">TYPE</span><span style="color:#ff79c6">)</span>
@Retention<span style="color:#ff79c6">(</span>RetentionPolicy<span style="color:#ff79c6">.</span><span style="color:#50fa7b">RUNTIME</span><span style="color:#ff79c6">)</span>
@Documented
@Inherited
@AutoConfigurationPackage
@Import<span style="color:#ff79c6">(</span>AutoConfigurationImportSelector<span style="color:#ff79c6">.</span><span style="color:#50fa7b">class</span><span style="color:#ff79c6">)</span>
<span style="color:#8be9fd;font-style:italic">public</span> @interface EnableAutoConfiguration <span style="color:#ff79c6">{</span> <span style="color:#ff79c6">...</span> <span style="color:#ff79c6">}</span>
</code></pre></div><p>该注解帮助SpringBoot应用将所有符合条件的<code>@Configuration</code>配置都加载到当前IoC容器中，如：</p>
<p>
  <img src="https://cdn.jsdelivr.net/gh/edgarding77/images@latest/default/spring-enableautoconfiguration.png" alt="图片">

</p>
<p>总的来说，从 <code>ClassPath</code>下扫描所有的 <code>META-INF/spring.factories</code> 配置文件，并将<code>spring.factories</code>文件中的 <code>EnableAutoConfiguration</code>对应的配置项通过反射机制实例化为对应标注了 <code>@Configuration</code> 的形式的IoC配置类，然后注入IoC容器。</p>
<h4 id="componentscan">@ComponentScan</h4>
<p>用于将一些标注了特定注解的bean定义批量采集注册到Spring的IoC容器中，这些注解常见有：</p>
<ul>
<li>@Controller</li>
<li>@Entity</li>
<li>@Component</li>
<li>@Service</li>
<li>@Repository</li>
<li>…</li>
</ul>
<h2 id="ioc">IoC</h2>
<h3 id="介绍">介绍</h3>
<p>Spring框架提供的很重要的一个作用就是IoC容器，而这里的容器就是指为某种特定组件的运行提供一个必要的软件环境，例如Tomcat就是一个Servlet容器，可以为Servlet提供运行时。通常来说，使用容器运行组件，除了提供一个组件的运行时，还提供了许多底层服务，如Servlet的底层实现了TCP连接、HTTP协议解析等复杂服务，若没有容器来提供这些服务，也没法使我们简单的编写Servlet代码。</p>
<p>Spring的核心就是IoC容器，可以管理所有轻量级的JavaBean组件，提供底层服务包括组件的生命周期管理、配置和组装服务、AOP支持等。</p>
<h3 id="ioc原理">IoC原理</h3>
<p>IoC（Inverse of Control：控制反转）是一种设计思想，**就是将原本在程序中手动创建对象的控制权，交给由Spring框架管理。**IoC容器是Spring用来实现IoC的载体，IoC容器实际上就是个Map，Map中存放的是各种对象。</p>
<p>将对象之间的相互依赖关系交给IoC容器管理，并由IoC容器完成对象的注入。即很大程度的简化了应用的开发，把应用从复杂的依赖关系中解放出来。<strong>IoC容器就像一个工厂，当我们需要创建一个对象的时候，只需要配置好配置文件/注解，完全不用考虑对象如何被创建。</strong></p>
<blockquote>
<p>在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
</blockquote>
<h4 id="依赖倒置原理">依赖倒置原理</h4>
<p>把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况。</p>
<p><strong>控制反转（Inversion of Control）</strong> 就是<strong>依赖倒置</strong>原则的一种代码设计的思路。具体采用的方法就是所谓的<strong>依赖注入（Dependency Injection）</strong>，它解决的最主要的一个问题就是：将组件的创建+配置与组件的使用分离，并且，由IoC容器负责管理组件生命周期。</p>
<h4 id="核心思想">核心思想</h4>
<p><strong>Inverseion of Control的最核心的思想就是，资源不由使用资源的双方管理，而由不使用资源的第三方管理。</strong></p>
<p>这里有个很棒的例子：</p>
<p>就是甲方要达成某种目的不需要直接依赖乙方，只需要将目的告诉给第三个。例如甲方需要一台电脑，乙方卖一台电脑，乙方要将电脑卖出去也不需要找到甲方，也只需要将电脑寄托到淘宝（电商平台）去告诉我要卖一台电脑。这样甲乙双方进行交易活动，都不需要自己去找互相，相当于程序内部开放接口，而卖家由第三方作为参数传入。甲乙不相互依赖，只有在交易的时候产生联系，反之亦然，解决了甲乙直接进行交易之间的不信任，因为交易由第三方负责联系。</p>
<ul>
<li>而所谓的依赖注入，就是甲方开发接口，在需要的时候，将乙方注入进来。</li>
<li>而所谓的控制反转，就是甲乙双方不互相依赖，交易活动的进行不依赖于互相，整个活动的进行全部由第三方负责管理。</li>
</ul>
<h3 id="ioc功能">IoC功能</h3>
<p>IoC支持以下功能：</p>
<ul>
<li>依赖注入</li>
<li>依赖检查</li>
<li>自动装配</li>
<li>支持集合</li>
<li>制定初始化方法和销毁方法</li>
<li>支持回调某些方法（但是需要实现Spring接口，有侵入性）</li>
</ul>
<p>对于IoC来说，最重要的就是容器，容器管理着Bean的生命周期，控制着Bean的依赖注入。</p>
<h4 id="容器">容器</h4>
<p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p>
<ul>
<li><strong>BeanFactory</strong></li>
<li><strong>ApplicationContext</strong></li>
</ul>
<p><code>BeanFactory</code> 粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “<strong>低级容器</strong>”。</p>
<p><code>ApplicationContext</code> 可以称之为 “<strong>高级容器</strong>”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p>
<p><strong>低级容器</strong>与<strong>高级容器</strong>关系如下：</p>
<p>
  <img src="https://cdn.jsdelivr.net/gh/edgarding77/images@latest/default/spring-beanfactory.jpeg" alt="图片">

</p>
<ul>
<li>下面的 3 个绿色的，都是功能扩展接口，不展开讲</li>
<li>看下面的隶属 <code>ApplicationContext</code> 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 <code>getBean</code> 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。通常用户看到的就是 “高级容器”。但 BeanFactory 也非常够用啦！</li>
<li>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 <code>refresh</code> 刷新 Bean 工厂所有配置。生命周期事件回调等。</li>
</ul>
<h3 id="ioc启动过程">IoC启动过程</h3>
<p>IoC启动，即<code>ClassPathXmlApplicationContext</code>（简称CPAC）的构造过程。</p>
<ol>
<li>用户构造CPAC。</li>
<li>CPAC 首先访问了 “抽象高级容器” 的 final 的 <code>refresh</code> 方法，这个方法是模板方法。所以要回调子类（低级容器）的 <code>refreshBeanFactory</code> 方法，这个方法的作用是使用低级容器加载所有 <code>BeanDefinition</code> 和 <code>Properties</code>到容器中。</li>
<li>低级容器加载成功后，高级容器开始处理一些回调，例如 Bean 后置处理器。回调 <code>setBeanFactory</code> 方法。或者注册监听器等，发布事件，实例化单例 Bean 等等功能，这些功能。</li>
</ol>
<p>即通俗来说：</p>
<ol>
<li>低级容器 加载配置文件（xml、数据库、applet），并解析成<code>BeanDefinition</code>到低级容器中。</li>
<li>加载成功后，高级容器启动高级功能，例如接口回调、监听器、自动实例化单例、发布事件等等功能。</li>
</ol>
<p>当容器创建好，就会使用<code>getBean</code>方法，获取Bean，而<code>getBean</code>的流程如下：</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">sequenceDiagram;
	participant A as AbstractApplicationContext;
	participant B as AbstractBeanFactory;
	  A -&gt;&gt; A : getBeanFactory();
    A -&gt;&gt; B : getBean;
	loop 递归
    B -&gt;&gt; B : getBeanInternal;
    B -&gt;&gt; B : createBean;
    B -&gt;&gt; B : applyPropertyValues
    B -&gt;&gt; B : resolveValueIfNecessary;
    B -&gt;&gt; B : resolveManageMap;
    B -&gt;&gt; B : resolveReference;
  end;
</code></pre><p>可以看出，<code>getBean</code>操作都是在低级容器里操作的，而这个递归操作指：但BeanA依赖于BeanB，而这个BeanA加载的时候，其配置的<code>ref=&quot;Bean_B&quot;在解析的时候只是一个占位符</code>，被放入BeanA的属性集合中，当调用<code>getBean</code>的时候，需要真正BeanB注入到BeanA时，就需要冲容器中获取该<code>Bean_B</code>，因此产生了递归。</p>
<blockquote>
<p>为什么不是在加载的时候直接注入？</p>
<p>因为加载的顺序不同，很可能BeanA依赖的BeanB没有加载好，就无法从容器中获取。因此，Spring将其分为了两个步骤：</p>
<ol>
<li>加载所有Bean配置成<code>BeanDefinition</code>到容器，如果Bean有依赖关系，则使用占位符暂时代替。</li>
<li>然后，在调用 <code>getBean</code> 的时候，进行真正的依赖注入，即如果碰到了属性是 <code>ref</code> 的（占位符），那么就从容器里获取这个 Bean，然后注入到实例中 —— 称之为依赖注入。</li>
</ol>
</blockquote>
<p>依赖注入实际上只需要“低级容器”就可以实现。</p>
<h3 id="bean的生命周期">Bean的生命周期</h3>
<p>Spring Bean的生命周期可以简单概括为4个步骤：</p>
<ol>
<li>实例化，创建一个Bean对象</li>
<li>填充属性，为属性赋值</li>
<li>初始化
<ul>
<li>如果实现了<code>xxxAware</code>接口，通过不同类型的Aware接口拿到Spring容器的资源</li>
<li>如果实现了<code>BeanPostProcessor</code>接口，则会回调该接口的<code>postProcessBeforeInitialzation</code>和<code>postProcessAfterInitialization</code>方法</li>
<li>如果配置了<code>init-method</code>方法，则会执行<code>init-method</code>配置的方法</li>
</ul>
</li>
<li>销毁
<ul>
<li>容器关闭后，如果Bean实现了<code>DisposableBean</code>接口，则会回调该接口的<code>destroy</code>方法</li>
<li>如果配置了<code>destroy-method</code>方法，则会执行<code>destroy-method</code>配置的方法</li>
</ul>
</li>
</ol>
<h3 id="相关注解">相关注解</h3>
<p><strong>这里只会提及注解的方式：</strong></p>
<ul>
<li>@Autowired：使用<code>@Autowired</code>就相当于把指定类型的Bean注入到指定的字段中
<ul>
<li>@Autowired(required = false)：Spring如果没有找到对应类型的Bean，它会抛出<code>NoSuchBeanDefinitionException</code>异常，可以通过该方式，若找不到就忽略</li>
</ul>
</li>
<li>@Compoent：相当于定义了一个Bean
<ul>
<li>@Scope：默认为单例，可以修改成<code>@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</code>，即<code>@Scope(&quot;prototype&quot;)</code></li>
</ul>
</li>
<li>@CompoentScan：过把所有标注为<code>@Component</code>的Bean自动创建出来，并根据<code>@Autowired</code>进行装配</li>
<li>@Configuration：标注是一个配置类，其主要目的是作为bean定义的源</li>
<li>@Bean：通过在<code>@Configuration</code>的配置类中创建第三方Bean
<ul>
<li>@Qualifier(“name”)：若Bean的类型相同，而容器只会创建一个实例，就需要使用别名来进行区分：<code>@Bean(&quot;name&quot;)</code>，这时候在使用的时候需要通过<code>@Qualifier(&quot;name&quot;)</code>来指定注入的Bean</li>
<li>@Primary：或者通过该注解设置为主要Bean</li>
</ul>
</li>
<li>@Order：场景：有些时候，我们会有一系列接口相同，不同实现类的Bean。因为Spring是通过扫描classpath获取所有的Bean，这时候可以通过该注解定义Bean添加顺序。</li>
<li>@PostContruct和<code>init()</code>：调用标记有<code>@PostConstruct</code>的<code>init()</code>方法进行初始化。</li>
<li>@PreDestory和<code>shutdown()</code>：而销毁时，容器会首先调用标记有<code>@PreDestroy</code>的<code>shutdown()</code>方法。</li>
</ul>
<h2 id="aop">AOP</h2>
<h3 id="介绍-1">介绍</h3>
<p>AOP(Aspect-Oriented Programming：面向切面编程)，通过<strong>预编译方式和运行期动态代理</strong>实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p><strong>主要功能：让关注点代码与业务代码分离</strong>。</p>
<p><strong>面向切面编程：对很多功能具有重复代码抽取，再在运行的时候往业务方法上动态注入“切面类代码”</strong>。</p>
<p>在Java上，对于AOP的织入由三种方式：</p>
<ol>
<li>编译器：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并拓展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li>
<li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li>
<li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li>
</ol>
<p>最简单的就是第三种返回式，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a href="https://github.com/cglib/cglib">CGLIB</a>或者<a href="https://www.javassist.org/">Javassist</a>这些第三方库实现。</p>
<h3 id="术语案例">术语&amp;案例</h3>
<p>AOP中的常用术语：</p>
<ul>
<li>Aspect：切面，即一个横跨多个核心逻辑的功能，或者成为系统关注点</li>
<li>Joinpoint：连接点，定义在应用程序流程的何处插入Aspect的执行</li>
<li>Pointcut：切入点，即一组连接点的集合</li>
<li>Advice：增强，指特定Joinpoint上执行的动作</li>
<li>Introduction：引介，指一个已有的Java对象动态地增加新的接口</li>
<li>Weaving：织入，将Aspect整合到程序的执行流中</li>
<li>Interceptror：拦截器，一种实现Advice的方法</li>
<li>Traget Object：目标对象，即真正执行业务的核心逻辑对象</li>
<li>AOP Proxy：AOP代理，是客户端持有的增强后的对象引用</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Aspect
@Component
<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">LoggingAspect</span> <span style="color:#ff79c6">{</span>
    <span style="color:#6272a4">// 在执行UserService的每个方法前执行:
</span><span style="color:#6272a4"></span>    @Before<span style="color:#ff79c6">(</span><span style="color:#f1fa8c">&#34;execution(public * com.itranswarp.learnjava.service.UserService.*(..))&#34;</span><span style="color:#ff79c6">)</span>
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">doAccessCheck</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">err</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span><span style="color:#f1fa8c">&#34;[Before] do access check...&#34;</span><span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">}</span>

    <span style="color:#6272a4">// 在执行MailService的每个方法前后执行:
</span><span style="color:#6272a4"></span>    @Around<span style="color:#ff79c6">(</span><span style="color:#f1fa8c">&#34;execution(public * com.itranswarp.learnjava.service.MailService.*(..))&#34;</span><span style="color:#ff79c6">)</span>
    <span style="color:#8be9fd;font-style:italic">public</span> Object <span style="color:#50fa7b">doLogging</span><span style="color:#ff79c6">(</span>ProceedingJoinPoint pjp<span style="color:#ff79c6">)</span> <span style="color:#8be9fd;font-style:italic">throws</span> Throwable <span style="color:#ff79c6">{</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">err</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span><span style="color:#f1fa8c">&#34;[Around] start &#34;</span> <span style="color:#ff79c6">+</span> pjp<span style="color:#ff79c6">.</span><span style="color:#50fa7b">getSignature</span><span style="color:#ff79c6">());</span>
        Object retVal <span style="color:#ff79c6">=</span> pjp<span style="color:#ff79c6">.</span><span style="color:#50fa7b">proceed</span><span style="color:#ff79c6">();</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">err</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span><span style="color:#f1fa8c">&#34;[Around] done &#34;</span> <span style="color:#ff79c6">+</span> pjp<span style="color:#ff79c6">.</span><span style="color:#50fa7b">getSignature</span><span style="color:#ff79c6">());</span>
        <span style="color:#ff79c6">return</span> retVal<span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>拦截器类型：</p>
<ul>
<li>@Before：这种拦截器先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</li>
<li>@After：这种拦截器先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</li>
<li>@AfterReturning：和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；</li>
<li>@AfterThrowing：和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</li>
<li>@Around：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。</li>
</ul>
<h3 id="spring-aop和aspectj-aop区别">Spring AOP和AspectJ AOP区别</h3>
<p>Spring AOP基于动态代理实现，属于运行时增强。</p>
<p>AspectJ则属于编译时增强，主要有三种方式：</p>
<ol>
<li>编译时织入：指的是增强的代码和源代码我们都有，直接使用 AspectJ 编译器编译就行了，编译之后生成一个新的类，他也会作为一个正常的 Java 类装载到JVM。</li>
<li>编译后织入：指的是代码已经被编译成 class 文件或者已经打成 jar 包，这时候要增强的话，就是编译后织入，比如你依赖了第三方的类库，又想对他增强的话，就可以通过这种方式。</li>
<li>加载时织入：指的是在 JVM 加载类的时候进行织入。</li>
</ol>
<h2 id="spring启动监听">Spring启动监听</h2>
<h3 id="概览">概览</h3>
<p><em>该小节，主要说明Spring容器启动时实现自己的逻辑，如创建定时任务、创建连接池等。</em></p>
<p>主要针对以下几种Spring启动监听方式：</p>
<ul>
<li>Bean 构造函数方式</li>
<li>使用 @PostConstruct 注解</li>
<li>实现 InitializingBean 接口</li>
<li>监听 ApplicationListener 事件</li>
<li>使用 Constructor 注入方式</li>
</ul>
<h3 id="原始方式">原始方式</h3>
<p>倘若没有Spring，回归Java本身，可以在静态代码块，在类构造函数中实现相应的逻辑，Java类的初始化顺序依次是：<strong>静态变量 -&gt; 静态代码块 -&gt; 全局变量 -&gt; 初始化代码块 -&gt; 构造器</strong></p>
<h3 id="postconstruct">@PostConstruct</h3>
<p>通过<code>@PostConstruct</code>在Bean初始化后实现相应的初始化逻辑，<code>@PostConstruct</code>修饰的方法将在Bean初始化完成之后执行，此时Bean的依赖也已经注入完成，因此可以在方法中调用注入的依赖Bean:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Component
<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">CustomBean</span> <span style="color:#ff79c6">{</span>
  	@Autowired
  	<span style="color:#8be9fd;font-style:italic">private</span> Environment env<span style="color:#ff79c6">;</span>
		@PostConstruct
  	<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">init</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
      	env<span style="color:#ff79c6">.</span><span style="color:#50fa7b">getActiveProfiles</span><span style="color:#ff79c6">();</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>与<code>@PostConstruct</code>相对应的，如果想在 Bean 注销时完成一些清扫工作，如关闭线程池等，可以使用<code>@PreDestroy</code>注解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Component
<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">CustomBean</span> <span style="color:#ff79c6">{</span>
    @Autowired
    <span style="color:#8be9fd;font-style:italic">private</span> ExecutorService executor <span style="color:#ff79c6">=</span> Executors<span style="color:#ff79c6">.</span><span style="color:#50fa7b">newFixedThreadPool</span><span style="color:#ff79c6">(</span>1<span style="color:#ff79c6">)</span>
		@preDestory
  	<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">destroy</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
      	executor<span style="color:#ff79c6">.</span><span style="color:#50fa7b">close</span><span style="color:#ff79c6">();</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><h3 id="initializingbean">InitializingBean</h3>
<p>实现Spring的<code>InitializingBean</code>接口同样可以实现以上在 Bean 初始化完成之后执行相应逻辑的功能。实现<code>InitializingBean</code>接口，在<code>afterPropertiesSet</code>方法中实现逻辑。</p>
<h3 id="applicationlistener">ApplicationListener</h3>
<p>我们可以在 Spring 容器初始化的时候实现我们想要的初始化逻辑。这时我们就可以使用到 Spring 的初始化事件。Spring 有一套完整的事件机制，在 Spring 启动的时候，Spring 容器本身预设了很多事件，在 Spring 初始化的整个过程中在相应的节点触发相应的事件，我们可以通过监听这些事件来实现我们的初始化逻辑。Spring 的事件实现如下：</p>
<ul>
<li>ApplicationEvent，事件对象：由 ApplicationContext 发布，不同的实现类代表不同的事件类型。</li>
<li>ApplicationListener，监听对象：任何实现了此接口的 Bean 都会收到相应的事件通知。实现了 ApplicationListener 接口之后，需要实现方法 <code>onApplicationEvent()</code>，在容器将所有的 Bean 都初始化完成之后，就会执行该方法。</li>
</ul>
<p>与 Spring Context 生命周期相关的几个事件有以下几个：</p>
<ul>
<li>ApplicationStartingEvent: 这个事件在 Spring Boot 应用运行开始时，且进行任何处理之前发送（除了监听器和初始化器注册之外）。</li>
<li>ContextRefreshedEvent: ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext 接口中使用 refresh() 方法来发生。</li>
<li>ContextStartedEvent: 当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被触发。你可以查询你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</li>
<li>ApplicationReadyEvent: 这个事件在任何 application/ command-line runners 调用之后发送。</li>
<li>ContextClosedEvent: 当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被触发。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</li>
<li>ContextStoppedEvent: Spring 最后完成的事件。</li>
</ul>
<p>因此，如果我们想在 Spring 启动的时候实现一些相应的逻辑，可以找到 Spring 启动过程中符合我们需要的事件，通过监听相应的事件来完成我们的逻辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Component
@Slf4j
<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">StartupApplicationListenerExample</span> <span style="color:#8be9fd;font-style:italic">implements</span> ApplicationListener<span style="color:#ff79c6">&lt;</span>ContextRefreshedEvent<span style="color:#ff79c6">&gt;</span> <span style="color:#ff79c6">{</span>

    @Override
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">onApplicationEvent</span><span style="color:#ff79c6">(</span>ContextRefreshedEvent event<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        log<span style="color:#ff79c6">.</span><span style="color:#50fa7b">info</span><span style="color:#ff79c6">(</span><span style="color:#f1fa8c">&#34;Subject ContextRefreshedEvent&#34;</span><span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>除了通过实现<code>ApplicationListener</code>接口来监听相应的事件，Spring 的事件机制也实现了通过<code>@EventListener</code>注解来监听相对应事件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Component
@Slf4j
<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">StartupApplicationListenerExample</span> <span style="color:#ff79c6">{</span>

    @EventListener
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">onApplicationEvent</span><span style="color:#ff79c6">(</span>ContextRefreshedEvent event<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        log<span style="color:#ff79c6">.</span><span style="color:#50fa7b">info</span><span style="color:#ff79c6">(</span><span style="color:#f1fa8c">&#34;Subject ContextRefreshedEvent&#34;</span><span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><h3 id="构造器constructor注入">构造器Constructor注入</h3>
<p>在成员变量上通过<code>@Autoware</code>注解注入依赖 Bean，但是在 Bean 的构造函数函数中却无法使用到注入的 Bean（因为 Bean 还未注入），其实我们也是使用 Spring 的构造函数注入方式， 这也是 Spring 推荐的注入机制（在我们使用 IDEA 的时候，如果没有关闭相应的代码 Warning 机制，会发现在成员变量上的<code>@Autoware</code>是黄色的，也就是 idea 不建议的代码）。Spring 更推荐构造函数注入的方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Component
<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">CustomBean</span> <span style="color:#ff79c6">{</span>
  	<span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">final</span> Environment env<span style="color:#ff79c6">;</span>
		
    @Autowired
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#50fa7b">LogicInConstructorExampleBean</span><span style="color:#ff79c6">(</span>Environment environment<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">environment</span> <span style="color:#ff79c6">=</span> environment<span style="color:#ff79c6">;</span>
        log<span style="color:#ff79c6">.</span><span style="color:#50fa7b">info</span><span style="color:#ff79c6">(</span>Arrays<span style="color:#ff79c6">.</span><span style="color:#50fa7b">asList</span><span style="color:#ff79c6">(</span>environment<span style="color:#ff79c6">.</span><span style="color:#50fa7b">getDefaultProfiles</span><span style="color:#ff79c6">()));</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><h2 id="常见问题">常见问题</h2>
<h3 id="spring循环依赖问题">Spring循环依赖问题</h3>
<p>「What」Spring循环依赖问题是什么？有三种情况：</p>
<ol>
<li>自己依赖自己</li>
<li>两个对象之间相互直接依赖</li>
<li>多个对象之间相互间接依赖</li>
</ol>
<p>如场景：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Service
<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">TestService1</span> <span style="color:#ff79c6">{</span> <span style="color:#6272a4">// A
</span><span style="color:#6272a4"></span>  	@Autowired
  	TestService2 testService2<span style="color:#ff79c6">;</span>
<span style="color:#ff79c6">}</span>
@Service
<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">TestService2</span> <span style="color:#ff79c6">{</span> <span style="color:#6272a4">// B
</span><span style="color:#6272a4"></span>  	@Autowired
  	TestService1 testService1<span style="color:#ff79c6">;</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>是一个很明显的循环依赖，但得益于spring的内部机制，让我们根本无法感知它有问题，因为spring默默帮我们解决了。</p>
<p>Spring解决循环依赖的两个前提条件：</p>
<ol>
<li>不全是构造器方式的循环依赖</li>
<li>必须是单例</li>
</ol>
<p>解决循环依赖的方式就是<strong>三级缓存</strong>，通过三级缓存提前拿到未初始化的对象。：</p>
<ul>
<li>singletonObjects 一级缓存，用于保存实例化、注入、初始化完成的bean实例。</li>
<li>earlySingletonObjects 二级缓存，用于保存实例化完成的bean实例，但是未初始化完成的对象。</li>
<li>singletonFactories 三级缓存，用于保存bean对象工厂，提供匿名内部类，用于创建二级缓存中的对象。</li>
</ul>
<p>
  <img src="https://cdn.jsdelivr.net/gh/edgarding77/images@latest/default/spring-circulardependencies.png" alt="图片">

</p>
<p>A对象的创建过程如下：</p>
<ol>
<li>创建对象A，实例化时将A放入三级缓存。</li>
<li>A注入属性，发现依赖B，转而初始化B。</li>
<li>同样创建对象B，注入属性时发现依赖A，依次从一级到三级缓存查询A，从三级缓存的对象工程拿到A，将A放入二级缓存，同时删除三级缓存的A，此时B已经实例化并初始化成功，将B放入一级缓存。</li>
<li>接着继续创建A，顺利从一级缓存中拿到B，A也实例化并初始化完成，同时删除二级缓存中的A，并放入到一级缓存中。</li>
<li>最后，一级缓存都保留了完成后的A，B</li>
</ol>
<p>Reference：https://mp.weixin.qq.com/s/m2DrtDxBzShtNF2Uk6zSAg</p>
<h3 id="为什么需要三级二级缓存不行么">为什么需要三级？二级缓存不行么？</h3>
<p>不可以，主要是为了生成代理对象。因为三级缓存中放的是生成具体对象的匿名内部类，他可以生成代理对象，也可以是普通的实例对象。</p>
<p>使用三级缓存主要是为了保证不管什么时候使用的都是一个对象。</p>
<p>假设只有二级缓存的情况，往二级缓存中放的显示一个普通的Bean对象，<code>BeanPostProcessor</code>去生成代理对象之后，覆盖掉二级缓存中的普通Bean对象，那么多线程环境下可能取到的对象就不一致了。</p>
<h2 id="常见注解">常见注解</h2>
<h3 id="value">@Value</h3>
<p>通过<code>@Value</code>可以将指定的配置属性，注入到字段中。该注解指定的系统属性名，必须与配置文件相同。</p>
<p>使用的时候会出现如下问题：</p>
<ol>
<li>编码问题：若使用<code>.properties</code>进行配置，SpringBoot会使用<code>CharacterReader</code>类负责读取，默认编码格式为<code>ISO-8859-1</code>，因此使用中文会出现乱码；而若使用<code>.yml/.yaml</code>配置，最终会使用<code>UnicodeReader</code>类进行解析，它的<code>init</code>会读取BOM文件头，并采用相应的编码，默认为<code>UTF-8</code>。</li>
<li>默认值的问题：场景，在Business层包含了UserService类，被API和JOB服务引用，但是<code>@Value</code>只被API服务引用，而JOB服务找不到该属性，因此为了避免启动报错，最好设置一个默认值<code>@Value(value = &quot;${djj.test.username:djj}&quot;)</code>，通过‘:’来设置。</li>
<li><code>static</code>修饰的字段不可使用。</li>
<li>注意<code>${}</code>和<code>#{}</code>的区别，<code>#{}</code>是获取Bean的属性或调用某个方法，<code>${}</code>主要是获取配置属性。</li>
</ol>
<p>更多细节参考：https://mp.weixin.qq.com/s/LGYSChfDLKuCQVMYGi0Omg</p>
<h3 id="autowired">@Autowired</h3>
<p>将<code>@Autowired</code>标注在类文件中的字段属性上，通过该方式，Spring容器启动时会寻找到相应的<strong>Bean</strong>，通过反射的方式注入到这个字段中。</p>
<p>若采用构造方法，若该类不存在无参构造，仅存在有参的构造函数，Spring也会注入相应的属性。</p>
<p>最后一种方式，Spring 可以使用 <code>@Autowired</code> 标注 <code>Array</code> (数组)，<code>Collections</code>(集合)，甚至是 <code>Map</code> (散列表)，通过这种方式注入多个相同类型的 <code>Bean</code>。</p>
<p>若需要指定里面的排序优先级，就需要使用<code>@Order</code>或者<code>@Priority</code>指定以下优先级，其中<code>@Order/@Priority</code>的值越小，优先级越高。</p>
<blockquote>
<p>这里注意，Spring中将先初始化Bean，然后调用类的构造函数，其次再注入成员变量依赖的Bean(@Autowired或@Resource)。</p>
</blockquote>
<h3 id="transactional">@Transactional</h3>
<p>添加位置：</p>
<ol>
<li>接口实现类 或 接口方法上 而不是接口类中</li>
<li>访问权限：public的方法才起作用。Spring AOP的本质决定（<strong>本质跟AOP调用有关：在事务代理对象中有判断代理的方法必须是public修饰，否则返回null</strong>）。</li>
</ol>
<p>系统设计：将标签放置在需要进行事务管理的方法上，而不是放在所有接口实现类上：只读的接口就不需要事务管理，由于配置了@Transactional就需要AOP拦截及事务的处理，可能影响系统性能。</p>
<p>错误使用：</p>
<blockquote>
<p>1.接口中A、B两个方法，A无@Transactional标签，B有，上层通过A间接调用B，此时事务不生效。</p>
<p>2.接口中异常（运行时异常）被捕获而没有被抛出。
默认配置下，spring 只有在抛出的异常为运行时 unchecked 异常时才回滚该事务，
也就是抛出的异常为RuntimeException 的子类(Errors也会导致事务回滚)，
而抛出 checked 异常则不会导致事务回滚 。可通过 @Transactional rollbackFor进行配置。</p>
<p>3.多线程下事务管理因为线程不属于 spring 托管，故线程不能够默认使用 spring 的事务,也不能获取spring 注入的 bean 。
在被 spring 声明式事务管理的方法内开启多线程，多线程内的方法不被事务控制。
一个使用了@Transactional 的方法，如果方法内包含多线程的使用，方法内部出现异常，不会回滚线程中调用方法的事务。</p>
</blockquote>
<p>@Transactional 实质是使用了 JDBC 的事务来进行事务控制的
@Transactional 基于 Spring 的动态代理的机制</p>
<blockquote>
<p>@Transactional 实现原理：</p>
<ol>
<li>事务开始时，通过AOP机制，生成一个代理connection对象，
并将其放入 DataSource 实例的某个与 DataSourceTransactionManager 相关的某处容器中。
在接下来的整个事务中，客户代码都应该使用该 connection 连接数据库，
执行所有数据库命令。
[不使用该 connection 连接数据库执行的数据库命令，在本事务回滚的时候得不到回滚]
（物理连接 connection 逻辑上新建一个会话session；
DataSource 与 TransactionManager 配置相同的数据源）</li>
<li>事务结束时，回滚在第1步骤中得到的代理 connection 对象上执行的数据库命令，
然后关闭该代理 connection 对象。
（事务结束后，回滚操作不会对已执行完毕的SQL操作命令起作用）</li>
</ol>
</blockquote>
<h2 id="实践功能">实践功能</h2>
<h3 id="autowird注入与构造函数注入">@Autowird注入与构造函数注入</h3>
<p>Spring4.3+后，constructor注入支持非显示注入方式。事实上，spring在4.x版本后就推荐使用构造器的方式的来注入fileld。</p>
<p>官方推荐理由：</p>
<ul>
<li>
<p>单一职责: 当使用构造函数注入的时候，你会很容易发现参数是否过多，这个时候需要考虑你这个类的职责是否过大，考虑拆分的问题；而当使用@Autowired注入field的时候，不容易发现问题</p>
</li>
<li>
<p>依赖不可变: 只有使用构造函数注入才能注入final</p>
</li>
<li>
<p>依赖隐藏: 使用依赖注入容器意味着类不再对依赖对象负责，获取依赖对象的职责就从类抽离出来，IOC容器会帮你自动装配。这意味着它应该使用更明确清晰的公用接口方法或者构造器，这种方式就能很清晰的知道类需要什么和到底是使用setter还是构造器</p>
</li>
<li>
<p>降低容器耦合度: 依赖注入框架的核心思想之一是托管类不应依赖于所使用的DI容器。换句话说，它应该只是一个普通的POJO，只要您将其传递给所有必需的依赖项，就可以独立地实例化。这样，您可以在单元测试中实例化它，而无需启动IOC容器并单独进行测试（使用一个可以进行集成测试的容器）。如果没有容器耦合，则可以将该类用作托管或非托管类，甚至可以切换到新的DI框架。</p>
</li>
</ul>
<h3 id="spring-factories机制">Spring Factories机制</h3>
<p>通过spring.factories实现<strong>解耦拓展机制</strong>。Spring Boot 应用中的”自动配置”是通过 <code>@EnableAutoConfiguration</code> 注解进行开启的。<code>@EnableAutoConfiguration</code> 可以帮助 Spring Boot 应用将所有符合条件的 <code>@Configuration</code> 配置类的 bean 都加载到 Spring IoC 容器中。</p>
<blockquote>
<p>SpringFactoriesLoader loads and instantiates factories of a given type from “META-INF/spring.factories” files which may be present in multiple JAR files in the classpath. The spring.factories file must be in Properties format, where the key is the fully qualified name of the interface or abstract class, and the value is a comma-separated list of implementation class names.</p>
</blockquote>
<p>spring-core 中的加载类 <code>SpringFactoriesLoader</code> 加载指定配置，该类会通过类加载器从 classpath 中搜索所有 <code>META-INF/spring.factories</code> 配置文件，然后获取 key 为 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 部分。</p>
<p>**Java SPI机制：**SPI 的全名为 Service Provider Interface，Java SPI 就是提供这样的一种机制：为某个接口寻找服务的实现的机制，有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制很重要。而spring factories就类似于该机制。</p>
<p>**使用场景：**当需要实现一些自定义的Spring Boot Starter，可以通过spring factories的机制，将自己的starter注册到<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>命名空间下，这样用户只需要在服务中引入jar包即可以完成自动加载和配置。</p>
<p><strong>Reference</strong></p>
<ul>
<li><a href="https://qidawu.github.io/2017/08/20/spring-factories/">Spring Boot 自动配置及 Factories 机制总结</a></li>
<li><a href="https://www.jianshu.com/p/7367dddab20d">spring boot中的spring factories机制</a></li>
</ul>
<h3 id="spring-beanfactoryaware">Spring BeanFactoryAware</h3>
<p><code>BeanFactory</code>是整个IOC容器的最顶层接口，规定了容器的行为，而实现了该接口，就表明当前类具有<code>BeanFactory</code>的能力。</p>
<p><code>BeanFactoryAware</code>接口中只有一个<code>setBeanFactory</code>方法。实现了<code>BeanFactoryAware</code>接口的类，可以在该<code>Bean</code>被加载的过程中获取加载该<code>Bean</code>的<code>BeanFactory</code>，同时也可以获取这个<code>BeanFactory</code>中加载的其它<code>Bean</code>。</p>
<p>关键是我们为什么需要通过<code>BeanFactory</code>的<code>getBean</code>来获取<code>Bean</code>呢？Spring已经提供了很多便捷的注入方式，那么通过<code>BeanFactory</code>的<code>getBean</code>来获取<code>Bean</code>有什么好处呢？</p>
<p>**好处：**通过实现<code>BeanFactoryAware</code>该接口，在调用者（客户端中），只需要通过一个beanName就可以实现不同实现类的切换。</p>
<p><strong>Reference</strong></p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1749642">https://cloud.tencent.com/developer/article/1749642</a></li>
<li><a href="https://juejin.cn/post/6844903661689110542">https://juejin.cn/post/6844903661689110542</a></li>
</ul>
<p><strong>具体实现</strong>：</p>
<p>在Knife4j的自定义spring-boot-starter中，为了实现不同服务下的swagger聚合，因此通过实现<code>BeanFactoryAware</code>接口，从而在进行聚合的时候，通过获取该Bean。</p>
<p>在大多数情况下，我们应该避免使用任何Aware接口，除非我们需要它们，实现这些接口会将代码耦合到Spring框架。</p>
<h3 id="spring-boot自定义配置自动提示">Spring Boot自定义配置自动提示</h3>
<p>官方提供的spring-boot-starter的配置项带有自动提示，而自己定义的配置却没有，对开发来说十分不优化，容易打错配置。</p>
<p><strong>提示原理</strong></p>
<p>IDE是通过读取配置信息的元数据而实现自动提示的，而元数据在目录META-INF中的spring-configuration-metadata.json 或者 additional-spring-configuration-metadata.json</p>
<p><strong>具体实现</strong></p>
<p>在工程下引入依赖：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#ff79c6">&lt;dependency&gt;</span>
    <span style="color:#ff79c6">&lt;groupId&gt;</span>org.springframework.boot<span style="color:#ff79c6">&lt;/groupId&gt;</span>
    <span style="color:#ff79c6">&lt;artifactId&gt;</span>spring-boot-configuration-processor<span style="color:#ff79c6">&lt;/artifactId&gt;</span>
    <span style="color:#ff79c6">&lt;optional&gt;</span>true<span style="color:#ff79c6">&lt;/optional&gt;</span>
<span style="color:#ff79c6">&lt;/dependency&gt;</span>
</code></pre></div><p>修改IDEA配置：</p>
<ol>
<li>搜索<code>Annotation Processor</code>并设置<code>Enable annotation processing</code></li>
<li>重新编译项目，项目在编译后会自动生成<code>spring-configuration-metadata.json</code>文件</li>
</ol>
<p><strong>Reference</strong></p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html">https://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html</a></li>
</ul>
<h3 id="enablecofigurationproperties注解">@EnableCofigurationProperties注解</h3>
<p>「What」@EnableConfigurationProperties注解的作用时：使得@ConfigurationProperties生效。</p>
<p><strong>@ConfigurationProperties</strong></p>
<p>使用@Value将Spring ENV bean访问这些属性的时候十分笨重，因此使用更安全的方式，且可以动态控制，因此使用@ConfigurationProperties来进行属性的获取。</p>
<p>基本用法如下，为每个要捕获的外部属性提供一个带有字段的类：</p>
<ul>
<li>前缀定义了哪些外部属性将要绑定到该类的字段上，如<code>@ConfigurationProperties(prefix = &quot;djj.security&quot;)</code></li>
<li>根据Spring Boot宽松的绑定原则，类的属性名程必须与外部属性匹配</li>
<li>类的本身可以是protected</li>
<li>类的字段必须有public setter方法</li>
</ul>
<blockquote>
<p>Spring 宽松绑定规则（relaxed binding）</p>
<p>Spring使用一些宽松的绑定属性规则。如以下变体都将绑定到hostName属性上：</p>
<pre tabindex="0"><code class="language-properties" data-lang="properties">mail.hostName=localhost
mail.hostname=localhost
mail.host_name=localhost
mail.host-name=localhost
mail.HOST_NAME=localhost
</code></pre></blockquote>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266265100383840">https://www.liaoxuefeng.com/wiki/1252599548343744/1266265100383840</a></li>
<li>IoC原理解析：https://mp.weixin.qq.com/s/0zRks2Cz36S8N70Uonb0OA</li>
<li>HowToDoInJava：https://www.kancloud.cn/apachecn/howtodoinjava-zh/1952630</li>
<li>Spel官方：https://docs.spring.io/spring-framework/docs/3.0.x/reference/expressions.html</li>
</ul>


                
                
<div class="entry-shang text-center">
    
	    <p>「真诚赞赏，手留余香」</p>
	
	<button class="zs show-zs btn btn-bred">赞赏支持</button>
</div>
<div class="zs-modal-bg"></div>
<div class="zs-modal-box">
	<div class="zs-modal-head">
		<button type="button" class="close">×</button>
		<span class="author"><a href="http://www.edgarding.cn"><img src="/img/favicon.png" />EdgarDing Blog</a></span>
        
	        <p class="tip"><i></i><span>真诚赞赏，手留余香</span></p>
		
 
	</div>
	<div class="zs-modal-body">
		<div class="zs-modal-btns">
			<button class="btn btn-blink" data-num="2">2元</button>
			<button class="btn btn-blink" data-num="5">5元</button>
			<button class="btn btn-blink" data-num="10">10元</button>
			<button class="btn btn-blink" data-num="50">50元</button>
			<button class="btn btn-blink" data-num="100">100元</button>
			<button class="btn btn-blink" data-num="1">任意金额</button>
		</div>
		<div class="zs-modal-pay">
			<button class="btn btn-bred" id="pay-text">2元</button>
			<p>使用<span id="pay-type">微信</span>扫描二维码完成支付</p>
			<img src="/img/reward/wechat-2.png"  id="pay-image"/>
		</div>
	</div>
	<div class="zs-modal-footer">
		<label><input type="radio" name="zs-type" value="wechat" class="zs-type" checked="checked"><span ><span class="zs-wechat"><img src="/img/reward/wechat-btn.png"/></span></label>
		<label><input type="radio" name="zs-type" value="alipay" class="zs-type" class="zs-alipay"><img src="/img/reward/alipay-btn.png"/></span></label>
	</div>
</div>
<script type="text/javascript" src="/js/reward.js"></script>

                

                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/post/2021/%E7%AE%97%E6%B3%954-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-suan-fa-4-dong-tai-gui-hua/" data-toggle="tooltip" data-placement="top" title="算法(4)-动态规划">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                </ul>
                

            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E7%AE%97%E6%B3%95" title="算法">
                            算法
                        </a>
                        
                        
                    </div>
                </section>
                

                
                
                <section>
                    <hr>
                    <h5>FRIENDS</h5>
                    <ul class="list-inline">
                        
                        <li><a target="_blank" href="https://fortuna7.top">oneday oneday 老博客</a></li>
                        
                    </ul>
                </section>
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    <li>
                        <a href="mailto:edgarding97@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    
                    

		            
                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/EdgarDing77">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    
                    
                    
                    
                    
                    
                    
                    
            
            
            <li>
                <a target="_blank" href="https://www.instagram.com/edgarding7/">
                    <span class="fa-stack fa-lg">
                        <i class="fas fa-circle fa-stack-2x"></i>
                        <i class="fab fa-instagram fa-stack-1x fa-inverse"></i>
                    </span>
                </a>
            </li>
            
            
           
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; EdgarDing Blog 2022
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a>
                    
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>









<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>





</body>
</html>
