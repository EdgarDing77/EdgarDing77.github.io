# record-2021-12

2021/12/26

- 登录 认证功能测试成功
- knife4j 文档中心配置与使用成功

- 登录成功，并未进行跳转

  - 排查代码：

    ```javascript
    success: function (response) {
      console.log(JSON.stringify(response));
      if (response.resp_code === 0) {
        config.putToken(response.data);
        // icon：-1 信息框 /0 加载框
        layer.msg('登录成功', {icon: 1, time: 500}, function () {
          location.replace("./");
        });
      } else {
        // 关闭所有加载层
        layer.closeAll('loading');
        layer.msg(response.resp_msg, {icon: 5, time: 500});
      }
    },
    ```

  - 打开浏览器检查，发现登录成功时返回的属性如下：

  ```
  {"data":{"access_token":"4d66f6dc-e3bd-498e-9c33-56b574996fb8","token_type":"bearer","refresh_token":"4af97ca7-5699-4320-99a6-a72b6f14cdfe","expires_in":1735,"scope":"app","account_type":"admin"},"responseCode":0,"responseMsg":""}
  ```

  而登录失败的属性如下：

  ```
  {"readyState":4,"responseText":"{\"error\":\"invalid_grant\",\"error_description\":\"验证码不存在或已过期\",\"resp_code\":\"400\",\"resp_msg\":\"验证码不存在或已过期\"}","responseJSON":{"error":"invalid_grant","error_description":"验证码不存在或已过期","resp_code":"400","resp_msg":"验证码不存在或已过期"},"status":400,"statusText":"Bad Request"}
  ```

  - 可以发现返回时的属性不一，从而导致逻辑判断有问题
  - 经过检查：发现自己定义CommonResult返回逻辑时有问题：

  ```java
  public class CommonResult<T> implements Serializable {
      private T data;
      private Integer responseCode; // 更改为 resp_code
      private String responseMsg; // 更改即可 resp_msg
  ...
  }
  ```

- Swagger 文档不生成｜找不到问题：knife4j-spring-ui在knife4j-spring-boot-starter中

  将网关sc-gateway pom.xml中`knife4j-micro-spring-boot-starter`替换成`knife4j-spring-boot-starter`

  - 启动后，报错`Knife4j文档请求异常`
  - 查看http请求发现请求路径：原本：`/swagger-resource` 修改成`/swagger-resources`。



2021/12/23

- 测试成功 - 能接受后端的数据



- 点击登录后出现：![截屏2021-12-23 下午8.46.42](https://cdn.jsdelivr.net/gh/edgarding77/microservice-platform-doc@latest/image/issue-2021-12-23-test.png)

  - https://segmentfault.com/q/1010000018166220
  - oauth_client_details表没有数据

- ```
  Warning: the font "Times" is not available, so "Lucida Bright" has been substituted, but may have unexpected appearance or behavor. Re-enable the "Times" font to remove this warning.
  ```

  - 解决方案：https://stackoverflow.com/questions/69631850/intellij-java-warning-times-and-lucida-bright-fonts-are-not-available
  - MacOS12 暂时没办法解决

- layui样式不加载`layui.js:29 Layui hint: config is not a valid module`

  - config（key重复，自己定义了重复的导致未被引用）

2021/12/21

- MyBatis分页插件失效，id插入顺序出问题

2021/12/20

- 测试 - 失败 debug
- [TODO] Mobile + Password + validate code 手机授权模式
- [TODO] Open ID方式
- Spring 事务为何只对public方法生效？
  **本质跟AOP调用有关：在事务代理对象中有判断代理的方法必须是public修饰，否则返回null**

2021/12/19
- djj-uaa 基本完成整个模块
- user-center、djj-uaa（demo）运行测试成功

- logback配置文件命名导致项目启动失败：[解决方案](https://www.jiweichengzhu.com/article/2f98919d236a4577aab22cd4057fd6fa)

- logback日志格式错误导致项目启动失败

- ```
  The web application [ROOT] appears to have started a thread named [redisson-netty-2-1] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
  ```

- uaa-server启动：

  ```
  ***************************
  APPLICATION FAILED TO START
  ***************************
  
  Description:
  
  Field userDetailsServiceFactory in top.edgarding.platform.uaa.config.WebSecurityConfig required a bean of type 'top.edgarding.infrastructure.common.feign.UserService' that could not be found.
  
  The injection point has the following annotations:
  	- @org.springframework.beans.factory.annotation.Autowired(required=true)
  
  
  Action:
  
  Consider defining a bean of type 'top.edgarding.infrastructure.common.feign.UserService' in your configuration.
  ```

  feign接口未注入，未能扫描到该包：解决：

  ```java
  @EnableFeignClients(basePackages = {"top.edgarding"})
  ```

- oauth_client_details创建，不然uaa-server启动报错，数据刷入失败。

- Nacos启动不支持 JDK11，需该用JDK8

2021/12/18

- djj-uaa 授权模式修改 进行删减，减少复杂性，日后增加oidc
- spring security + OAuth2 整个逻辑过程梳理

2021/12/14

- gateway使用feign请求的时候报HttpMessageConverters未注入异常，自行配置一个Decoder, 避免该异常。（sc-gateway FeignConfig）

2021/12/13

- djj-gateway开始
- spring boot项目使用Docker进行打包，docker相关命令问题



2021/12/11

- djj-Infrastructure基本通用逻辑完成

  - djj-auth-client-spring-boot-starter学习
  - 自定义RedisTokenStore，自动续签实现
  - Token续签
- 如何通过访问授权服务器获取非对称加密公钥 Key？具体实现？
  - 2021/12/13 已发现，URL为：`http://127.0.0.1:9900/api-uaa/tokens/key`

2021/12/10：

- spring security、OAuth2相关概念

2021/12/6:

- JWT的RSA非对称性密钥生成
- SSO-Demo实现前提：
  - djj-uaa：统一认证中心
  - user-center：用户服务
  - sc-gateway：api网关

- OAuth2学习[todo]
- 单点登录文档[todo]
- 登陆认证文档[todo]
- djj-auth-client-spring-boot-starter实现[todo]
- spring security学习：[学习地址](http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Spring%20Security%20%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%93%8D/00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%20Spring%20Security%EF%BC%8C%E4%B8%BA%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E4%B8%8E%E8%81%8C%E4%B8%9A%E4%B9%8B%E8%B7%AF%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA.md)

2021/12/5：

- 分布式锁，Spring的IOC和AOP细节回顾，aop简单demo复习
- 系统幂等性设计BaseService，需结合MyBatisPlus，系统幂等性BaseServiceImpl具体实现

2021/12/4：

- 分布式日志链路追踪[Done]
- TransitmitableThreadLocal学习
- djj-db-spring-boot-starter实现
- djj-common-spring-boot-starter和djj-common-core文档
- 分布式锁文档 Redis锁实现
- AOP方面的问题[TODO]
- MyBatisPlus

2021/12/3

- 分布式链路追踪问题实现
- 父子线程传递问题
- Transimitable-ThreadLocal使用
- Logback配置文件（学习）

2021/12/2：

- 审计日志文档
- 分布式日志链路追踪 80%
- djj-log-spring-boot-starter实现
- 重写logbackMDCAdapter（直接复制先有的）

- 2021/12/1:
  - Knife4j使用与学习，demo实现（swagger），BeanFactoryAware运用说明
  - redis-spring-boot-starter修改与学习
  - 项目清理和整理，从wolai转移到Typora进行编写
  - springfactories机制
  - Feign入门、loadbalancer通用逻辑文档编写，djj-loadbalancer-spring-boot-starter模块

  

2021/11/29：

- API：
  - ValidateCode
  - Token

2021/11/25：

- 一些技术考究

2021/11/23：

- MyBatis plus（未完成）

2021/11/22：

- Token解析resovler

2021/11/21

- 「What」(Assert使用方式？)：
  - https://www.liaoxuefeng.com/wiki/1252599548343744/1264740093521088
  - Java断言的特点是：断言失败时会抛出`AssertionError`，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解`JUnit`的使用。
- 「Issue」(网关启动报错`ResourceServerProperties`自动注入失败)：
- 「Issue」(`@Autowired和@Resource`)：
  - @Autowired注解是按类型装配依赖对象，默认下要求依赖对象必须存在；@Resource则默认按照名称装配。
  - @Resource是Java自己的注解，@Resource有两个属性是比较重要的，分是name和type；Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。@Autowired是spring的注解，是spring2.5版本引入的，Autowired只根据type进行注入，不会去匹配name。如果涉及到type无法辨别注入对象时，那需要依赖@Qualifier或@Primary注解一起来修饰。
- 「Issue」(Nacos部署失败，找不到启动类)：
  - Nacos不支持JDK11，更换JDK8即可
- 「How」(BeanFactoryAware如何使用)：
  - Aware接口是回调，监听器和观察者设计模式混合，表示bean有资格通过回调式被Spring容器通知。 BeanFactoryAware用于注入BeanFactory对象，这样我们就可以访问创建对象的BeanFactory。
  - https://cloud.tencent.com/developer/article/1749642
- 「Annotation」(@Import)：
  - @Import提供了@Bean注解的功能，@Import（name.class)优先于本身的类定义加载
  - https://zhuanlan.zhihu.com/p/147025312
- 「Class」(social.security依赖)：
  - https://projects.spring.io/spring-social/
  - 需要修改maven依赖的导入：
  - `spring-social-security`改成`spring-social-core`

- 「Class」(WebMvcConfigurer)：
  - https://docs.spring.io/spring-framework/docs/current/javadoc-api/index.html?org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html

2021/11/20：

- 多租户应用隔离，学习
- 分布式锁实现，redis-spring-boot-starter
- 「What」(META-INF/spring.factories文件)：
  - spring -core 包里定义了SpringFactoriesLoader 类，这个类实现了检索META-INF/spring.factories文件，并获取指定接口的配置的功能。 在这个类中定义了两个对外的方法
  - 在Spring boot 中也有一种类似的加载机制，它在META-INFO/spring.factories文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。

2021/11/19：

- 项目的基本构建

- 「What」(idea 中spring profile active是什么？)：
  - 用于区分配置
- 「What」(serialVersionUID)：
  - 参考：https://www.jianshu.com/p/91fa3d2ac892
  - 为每个序列化类生成版本标识用于版本校验；最好显式声明一个，因为不同的 jdk 编译很可能会生成不同的 serialVersionUID 默认值，进而导致在反序列化时抛出 InvalidClassExceptions 异常。所以，为了保证在不同的 jdk 编译实现中，其 serialVersionUID 的值也一致，可序列化的类必须显式指定 serialVersionUID 的值。另外，serialVersionUID 的修饰符最好是 private，因为 serialVersionUID 不能被继承，所以建议使用 private 修饰 serialVersionUID。
- 「What」(easypoi是什么？)：
  - 项目地址：https://github.com/jueyue/easypoi
  - **poi是**一个专门给Java程序提供格式文档读写功能的API接口，包括各种微软的格式文档入excel、word等。 最常用的还是Excel格式导入导出。 **Easypoi是**在**poi**接口基础上进行了封装，简化了操作



