# 开发说明

## 命名规则

### 模块命名

模块命名格式：

```
{prefix_name}-{module_name}
```

通用逻辑模块命名：

```
{prefix_name}-{module_name}-spring-boot-starter
```

tips：该模块为底层依赖，将被引用在具体项目模块中。

### 包命名

```
top.edgarding.{root_module_name}.{child_module_name}
```

抛开作为基础的依赖模块，其他模块的前缀均为`top.edgarding.platform`，例如网关：`top.edgarding.platform.gateway`

### 其它

文件命名：

- 图片命名：`{pictname-number}`以`-`做分割。
- 项目记录：`{year-month}`以`-`做分割。

JSR330标准：

- @Inject替代@Autowired来执行注入
- @Named替代@Component来声明一个Bean
- reference：https://elim168.github.io/spring/bean/17.对JSR330标注注解的支持.html

## 编码规范

### 编码命名

数据类型：

- boolean：`is{ObjectName}`，需要带有`is`前缀，如`isEnable`。
- Date ：`createTime`、`updateTime`分别为创建时间与更新时间

方法名：

- 更新和插入操作统一用一个方法：saveOrUpdate
- 查找以find作为前缀
- 删除某个单项使用delete全称。

### 接口规范

* 按照restful接口设计规范
  GET （SELECT）：从服务器检索特定资源，或资源列表。

  POST （CREATE）：在服务器上创建一个新的资源。

  PUT （UPDATE）：更新服务器上的资源，提供整个资源。

  PATCH （UPDATE）：更新服务器上的资源，仅提供更改的属性。

  DELETE （DELETE）：从服务器删除资源。

* 接口尽量使用名词，禁止使用动词，下面是一些例子

```java
GET         /zoos：列出所有动物园
POST        /zoos：新建一个动物园
GET         /zoos/{id}：获取某个指定动物园的信息
PUT         /zoos/{id}：更新某个指定动物园的信息（提供该动物园的全部信息）
PATCH       /zoos/{id}：更新某个指定动物园的信息（提供该动物园的部分信息）
DELETE      /zoos/{id}：删除某个动物园
GET         /zoos/{id}/animals：列出某个指定动物园的所有动物
DELETE      /zoos/{zId}/animals/{aId}：删除某个指定动物园的指定动物
```

* 反例：

```
/getAllCars
/createNewCar
/deleteAllRedCars
```

### 后端返回JSON

* 后端统一返回 CommonResult 对象
  * data：具体响应的其他信息
  * resp_code：响应码，目前0是成功、1是失败
  * resp_msg：响应消息

### 埋点日志规范

* 如果使用日志埋点的方式，建议按以下格式写日志

```
格式为：{时间}|{来源}|{对象id}|{类型}|{对象属性(以&分割)}

例子1：
2016-07-27 23:37:23|business-center|1|user-login|ip=xxx.xxx.xx&userName=张三&userType=后台管理员

例子2：
2016-07-27 23:37:23|file-center|c0a895e114526786450161001d1ed9|file-upload|fileName=xxx&filePath=xxx
```

### 工具类说明

每个工具类util都不应该被实例化，因此在进行编写时候根据《Effictive Java》可以私有化一个构造器，来确保不能被实例化。

## 逻辑开发说明

### Model说明

user-center主要实现用户信息与权限管理等逻辑，其中所有service都将依赖于以下model（存在于djj-infrastructure -> djj-common-core）：

1. SuperEntity<T extends Model<?>> extends Model\<T>：所有实体的父类，主要提供id、creatTime、updateTime属性。
   - [ActiveRecord](https://www.jianshu.com/p/dd9b471d08ea) 模式 CRUD
     必须存在对应的原始mapper并继承baseMapper并且可以使用的前提下 才能使用此 AR 模式 !!!
2. SysUser：用户
3. LoginAppUser：继承自SysUser使得用户带上权限列表的一个dto对象。
4. SysMenu：用户权限。实现URL级权限，因此需要细化权限，这里将权限实体化为Menu来表示，即菜单。
5. SysRole：用户角色。



关联表：无需继承SuperEntity中的id等属性，`extends Model<SysRoleUser>`即可。

1. SysRoleMenu：角色关联权限
2. SysRoleUser：用户关联角色

### 逻辑编写

需要满足以下逻辑

{/{id}}**delete**：删除逻辑，DELETE

{/}**list{Model}：**分页查找逻辑，GET

{/saveOrUpdate}**saveOrUpdate：**增改逻辑，POST

1. service接口 带有`@Transactional(rollbackFor = Exception.class)`
2. 是否为插入逻辑（id识别）
   1. 默认设置
3. 幂等性`saveOrUpdateIdempotency()`判断是否存在
   1. 存在则进行更新
      1. 先进行旧数据删除
   2. 不存在直接进行插入



对于返回结果集，若无需返回实体，按以下返回：

- succeed：“操作成功”
- failed：“操作失败” ｜ 具体失败原因（并使用日志记录）

### MVC开发

- Controller：
  - 注意命名格式：@Api(“{}模块api”) 

- Service：`extands BaseService<{model}>`，注意需要带上@Slf4j和@Service
- ServiceImpl：`extends BaseServiceImpl<{mapper}, {model}> implements {service}`
- Mapper：`extends SuperMapper<{model}>`

tips：编写Mybatis时，通用sql的id命名使用全大写。

### 分页逻辑开发说明

所有分页逻辑方法命名统一：list{ModelName}s

Controler：

```java
    @GetMapping("/roles")
    @ApiOperation(value = "分页角色列表")
    @ApiImplicitParams({
        @ApiImplicitParam(name = "page", value = "分页起始位置", required = true, dataType = "Integer"),
        @ApiImplicitParam(name = "limit", value = "分页结束位置", required = true, dataType = "Integer")
    })
    public PageResult<SysRole> listRoles(@RequestParam Map<String, Object> params) {
        return sysRoleService.listRoles(params);
    }
```

Service：`PageResult<SysRole> listRoles(Map<String, Object> params);`

ServiceImpl：

```java
    @Override
    public PageResult<SysRole> listRoles(Map<String, Object> params) {
        Integer curPage = MapUtil.getInt(params, "page");
        Integer limit = MapUtil.getInt(params, "limit");
        Page<SysRole> page = new Page<>(curPage == null ? 0 : curPage, limit == null ? -1 : limit);
        List<SysRole> roles = baseMapper.listRoles(page, params);
        return PageResult.<SysRole>builder().data(roles).code(0).count(page.getTotal()).build();
    }
```

Mapper：`List<SysRole> findList(Page<SysRole> sysRolePage, @Param("params") Map<String, Object> params);`

- @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位(你可以继承Page实现自己的分页对象)。

### 多级联动逻辑编写

这里以当前用户获取菜单的逻辑来进行说明：

1. Controller：通过@LoginUser注入username与roles（角色列表）

   ```java
       @GetMapping("/current")
       @ApiOperation("登录用户的菜单")
       public CommonResult findUserMenu(@LoginUser SysUser user) {
           List<SysRole> roles = user.getRoles();
           if (CollUtil.isEmpty(roles)) {
               return CommonResult.failed("用户角色为空");
           }
           // 实现的时候需要注意：多级菜单的循环构建
           List<SysMenu> menus =
               sysMenuService.findByRoleCode(roles.parallelStream().map(SysRole::getCode).collect(
                   Collectors.toSet()), CommonConstants.URL_MENU);
           return CommonResult.succeed(menus);
       }
   ```

2. Service：

   ```java
       @Override
       public List<SysMenu> findByRoleCode(Set<String> roleCodes, Integer type) {
           List<SysMenu> sysMenus = sysRoleMenuService.findMenusByRoleCodes(roleCodes, type);
           List<SysMenu> menus = new ArrayList<>();
           // 循环建树
           for (SysMenu sysMenu : sysMenus) {
               // 父菜单
               if (ObjectUtil.equal(-1L, sysMenu.getParentId())) {
                   menus.add(sysMenu);
               }
             	// 子菜单填充
               for (SysMenu menu : sysMenus) {
                   if (menu.getParentId().equals(sysMenu.getId())) {
                       if (sysMenu.getSubMenus() == null) {
                           sysMenu.setSubMenus(new ArrayList<>());
                       }
                       sysMenu.getSubMenus().add(menu);
                   }
               }
           }
           return menus;
       }
   ```

3. Mapper：

   ```XML
       <select id="findMenusByRoleCodes" resultType="top.edgarding.infrastructure.common.model.SysMenu">
           select distinct sm.*
           from `user-center`.sys_menu sm
           inner join `user-center`.sys_role_menu srm on srm.menu_id=sm.id
           inner join `user-center`.sys_role sr on sr.id=srm.role_id
           where
           sr.code in
           <foreach collection="roleCodes" index="index" item="roleCode" open="(" separator="," close=")">
               #{roleCode}
           </foreach>
           <if test="type != null">
               and sm.type=#{type}
           </if>
           and sm.hidden=0
           ORDER BY sort ASC
       </select>
   ```

## 服务开发说明

### 依赖选用

新服务添加在djj-bussiness目录下，以下依赖直接用`<artifactId>`表示：

基础依赖（必需）：

- djj-config
- djj-common-spring-boot-starter
- djj-swagger2-spring-boot-starter
- spring-cloud-starter-alibaba-nacos-discovery：nacos自动发现
- spring-boot-starter-web：web依赖

可选依赖：

- 数据库依赖：
  - djj-db-spring-boot-starter
  - mysql-connector-java
- 缓存依赖：
  - djj-redis-spring-boot-starter
- 服务调用依赖feign：
  - djj-loadbalancer-spring-boot-starter
- 限流、熔断、降级依赖：
  - djj-sentinel-spring-boot-starter
- 服务监控依赖：
  - spring-boot-starter-actuator：暴露endpoint
  - micrometer-registry-prometheus：集成prometheus

### 配置文件

bootstrap.yml主要有以下内容（修改服务端口与服务名）：

```yaml
server:
	port: {web端口}
spring:
	application:
		name: {server_name}
```

**application.yml具体看选用的依赖。**

### 必要代码

启动类：

```java
@EnableDiscoveryClient
@EnableFeignInterceptor
@EnableFeignClients
@SpringBootApplication
public class XXXApp {
    public static void main(String[] args) {
        SpringApplication.run(XXXApp.class, args);
    }
}
```

- **@EnableDiscoveryClient**：开启服务注册发现
- **@EnableFeignInterceptor**：开启 feign 拦截器，用于服务间参数传递
- **@EnableFeignClients**：如果需要使用 feign 调用其他服务，则必需添加，并通过 basePackages 属性指定 feign 服务的包路径
- **@SpringBootApplication**：Spring Boot 应用必需

配置类：

统一异常处理

```java
@ControllerAdvice
public class ExceptionAdvice extends DefaultExceptionAdvice {
}
```

web配置

```java
@Configuration
public class WebMvcConfig extends DefaultWebMvcConfig {
}
```

用于配置 `TokenArgumentResolver` 类，解析获取当前登录人信息，并注入到方法的 `@LoginUser SysUser user` 参数里

