# 登陆认证

## Introduction

认证Token主要有三种方式：

1. jwt
2. db
3. redis

若使用jwt方式，因为jwt使用的是非对称加密，所以认证服务djj-uua需要配置成`authJwt`为私钥加密，其他服务（例如网关）配置为`resJwt`为公钥解密。

token认证方式修改通过：

```yml
djj:
	oauth2:
		token:
			store:
				type: authJwt # redis, db, authJwt | resJwt(除认证服务外其他服务)
```

本项目是api网关统一认证的架构，适配有网络隔离的环境下使用。

## 访问请求

```bash
http://127.0.0.1:9000
admin/admmin
```

访问后端API需要带上Token

```
# 放header方式：
Authorization:Bearer xxx

# 放参数方式：
http://localhost:9900/api-user/users?access_token=xxx
```

前端具体请求构造：

```javascript
 /* 表单提交 */
        form.on('submit(loginSubmit)', function (obj) {
            layer.load(2, {time: 10 * 1000});
            $.ajax({
                url: config.base_server + 'api-uaa/oauth/token',
                type: 'POST',
                xhrFields: {
                    withCredentials: true
                },
                data: obj.field,
                beforeSend: function (xhr) {
                    xhr.setRequestHeader('Authorization', 'Basic ' + window.btoa(config.clientId + ":" + config.clientSecret));
                },
                success: function (response) {
                    console.log(JSON.stringify(response));
                    if (response.resp_code === 0) {
                        config.putToken(response.data);
                        // icon：-1 信息框 /0 加载框
                        layer.msg('登录成功', {icon: 1, time: 500},function () {
                            location.replace("./");
                        });
                    } else {
                        // 关闭所有加载层
                        layer.closeAll('loading');
                        layer.msg(response.resp_msg, {icon: 5, time: 500});
                    }
                },
                error: function (xhr) {
                    console.log(JSON.stringify(xhr));
                    layer.closeAll('loading');
                    layer.msg(xhr.responseJSON.resp_msg, {icon: 5, time: 500});
                }
            });
            // 阻止表单跳转
            return false;
        });
```



## token自动续签

本设计只针对redis token，该模式续签只会修改过期时间而不重新生成token，因为重新生成一个token会导致同一个账户下的其他客户端访问失效。

> 续签会有性能开销，所以设计了开关和黑白名单方便灵活控制，只有真正需要的业务才开放

![img](https://cdn.jsdelivr.net/gh/edgarding77/microservice-platform-doc@latest/image/func/redis-token-flow.png)

这里对RedisTokenStore进行重定制，具体类查看`{@link top.edgarding.infrastructure.authclient.store.CustomRedisTokenStore}`：

续签配置具体说明：

```yml
djj:
	security:
		auth:
			renew: # token自动续签配置
				enable: false # 默认为false
				includeClientIds: # 白名单，配置自动续签的id，不配置默认所有应用生效
        exclusiveClientIds: # 黑明单，配置不需要自动续签的AppId
        timeRatio: 0.5 # 默认0.5 续签时间比例，当前剩余时间小于过期总时长的50%则续签
```

- enable：全局Token续签配置是否开启
- includeClientIds&exclusiveClientIds：若两个都存在相同的clientId配置，则以黑名单为主即不开启自动续签。
- timeRatio：计算公式`currentTime - expireTime / expireTime - createTime`。

## URL级权限认证

### 角色认证说明

ROLE_HEADER：x-role-header

1. 用户认证成功后，将执行:

   1. CustomServerAuthenticationSuccessHandler.java 认证成功处理类

   2. ```java
              headerValues.add(SecurityConstants.ROLE_HEADER,
                  CollectionUtil.join(authentication.getAuthorities(), ","));
      ```

   3. 将role信息插入到header中，并以“,”分割，同时这里的getAuthorities来自LoginAppUser。

   4. ```java
      @Getter
      @Setter
      public class LoginAppUser extends SysUser implements SocialUserDetails {
          /***
           * 权限重写
           */
          @JsonIgnore
          @Override
          public Collection<? extends GrantedAuthority> getAuthorities() {
              Collection<GrantedAuthority> collection = new HashSet<>();
              if (!CollectionUtils.isEmpty(super.getRoles())) {
                  super.getRoles().parallelStream().forEach(role -> collection.add(new SimpleGrantedAuthority(role.getCode())));
              }
              return collection;
          }
      }
      ```

2. TokenArgumentResolver.java中resolveArgument获取ROLE_HEADER，并完成以下逻辑：

   ```java
           List<SysRole> sysRoles = new ArrayList<>();
           Arrays.stream(roles.split(",")).forEach(role -> {
               SysRole sysRole = new SysRole();
               sysRole.setCode(role);
               sysRoles.add(sysRole);
           });
           sysUser.setRoles(sysRoles);
   ```


## 登录方式

### 自定义方式

目前实现方式有：

- grant_type = password_code：username + password + validate code验证模式

#### password_code

该模式为对原有授权逻辑password的加强。使用username、password和validate code，实现网页验证模式。

扩展说明：

1. 添加一个新的grantType类型，并增加到对应的`TokenGranter`实现类，添加扩展内容。（具体方式：`PasswordCodeGranter extends ResourceOwnerPasswordTokenGranter`）
2. 然后加到`CompositeTokenGranter` 中的 `tokenGranters` 集合里即可。

增加校验逻辑即可：

```java
public class PasswordCodeGranter extends ResourceOwnerPasswordTokenGranter {
    private static final String GRANT_TYPE = "password_code";

    private final ValidateCodeService validateCodeService;

    public PasswordCodeGranter(AuthenticationManager authenticationManager, AuthorizationServerTokenServices tokenServices
        , ClientDetailsService clientDetailsService, OAuth2RequestFactory requestFactory, ValidateCodeService validateCodeService) {
        super(authenticationManager, tokenServices, clientDetailsService, requestFactory, GRANT_TYPE);
        this.validateCodeService = validateCodeService;
    }

    @Override
    protected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) {
        Map<String, String> parameters = new LinkedHashMap<>(tokenRequest.getRequestParameters());
      	// 在此添加拓展内容 校验逻辑即可
        String deviceId = parameters.get("deviceId");
        String validCode = parameters.get("validCode");
        validateCodeService.validate(deviceId, validCode);

        return super.getOAuth2Authentication(client, tokenRequest);
    }
}

```

这里详解下校验码的逻辑：

- 网页逻辑：

  ```java
      @Override
      public String createCode(String deviceId) {
          String code = RandomUtil.randomNumbers(SecurityConstants.VALIDATE_CODE_SIZE);
          redisRepository.setExpire(redisKey(deviceId), code,
              SecurityConstants.VALIDATE_CODE_EXPIRE);
          return code;
      }
  ```

- 手机逻辑：（该功能没法具体实现，只是实现逻辑）

  1. 先去redis 查询是否 60S内已经发送
  2. 未发送： 判断手机号是否存在 ? false :产生4位数字  手机号-验证码
  3. 发往消息中心-》发送信息
  4. 保存redis

  ```java
      @Override
      public CommonResult sendSmsCode(String mobile) {
          String tempCode = (String) redisRepository.get(redisKey(mobile));
          if (tempCode != null) {
              log.error("用户:{}验证码未失效{}", mobile, tempCode);
              return CommonResult.failed("验证码未失效，请失效后再次申请");
          }
  
          SysUser user = userService.findByMobile(mobile);
          if (user == null) {
              log.error("根据用户手机号 {} 查询用户为空", mobile);
              return CommonResult.failed("手机号不存在");
          }
  
          String code = RandomUtil.randomNumbers(SecurityConstants.VALIDATE_CODE_SIZE);
          log.info("短信发送请求消息中心 -> 手机号:{} -> 验证码：{}", mobile, code);
          redisRepository.setExpire(redisKey(mobile), code, SecurityConstants.VALIDATE_CODE_EXPIRE);
          return CommonResult.succeed("true");
      }
  ```

### 密码 - 验证码授权模式

请求API：`localhost:9001/users/saveOrUpdate`

```json
{
    "data": {
        "id": 1,
        "createTime": "2021-12-26T05:47:54.777+00:00",
        "updateTime": "2021-12-26T05:47:54.777+00:00",
        "username": "admin",
        "password": "{bcrypt}$2a$10$H5iFnJeqVtYmrx1d6XsNBOIRZB0LBvGLUpH2j2inDbhhP45q3yyJG",
        "nickname": "管理员",
        "headImgUrl": null,
        "mobile": "15112343188",
        "sex": null,
        "type": "ADMIN",
        "openId": null,
        "isEnable": true,
        "isDel": null,
        "roles": null,
        "roleId": null,
        "oldPassword": null,
        "newPassword": null
    },
    "responseCode": 0,
    "responseMsg": "操作成功"
}
```



登录成功后，会跳转到index.html触发api-user/users/current获取当前登录的用户：

```json
{"data":{"id":1,"createTime":"2021-12-26T05:47:55.000+00:00","updateTime":"2021-12-26T05:47:55.000+00:00","username":"admin","password":"{bcrypt}$2a$10$H5iFnJeqVtYmrx1d6XsNBOIRZB0LBvGLUpH2j2inDbhhP45q3yyJG","nickname":"管理员","headImgUrl":"0","mobile":"15112343188","sex":null,"type":"ADMIN","openId":null,"isEnable":true,"isDel":false,"roles":[],"roleId":null,"oldPassword":null,"newPassword":null,"permissions":null,"authorities":[],"accountNonExpired":true,"accountNonLocked":true,"credentialsNonExpired":true,"userId":null,"enabled":true},"resp_code":0,"resp_msg":""}
```

### 验证码

使用Hutool工具包`cn.hutool.captcha`.

验证码功能位于`cn.hutool.captcha`包中，核心接口为`ICaptcha`，此接口定义了以下方法：

- `createCode` 创建验证码，实现类需同时生成随机验证码字符串和验证码图片
- `getCode` 获取验证码的文字内容
- `verify` 验证验证码是否正确，建议忽略大小写
- `write` 将验证码写出到目标流中其中write方法只有一个`OutputStream`，`ICaptcha`实现类可以根据这个方法封装写出到文件等方法。

`AbstractCaptcha`为一个`ICaptcha`抽象实现类，此类实现了验证码文本生成、非大小写敏感的验证、写出到流和文件等方法，通过继承此抽象类只需实现`createImage`方法定义图形生成规则即可。

使用：

```java
ICaptcha captcha = CaptchaUtil.createLineCaptcha(100, 35, 4, 2);
validateCodeService.saveImageCode(deviceId, captcha.getCode());
captcha.write(response.getOutputStream());
```

**具体实现说明：**验证码通过deviceId（前端传入的唯一id，这里在前端设计上使用UUID来保证唯一性）和`captcha.getCode()`获取验证码内容，存入缓存中（VALIDATE_CODE_KEY:{deviceId}:{code})。

### 检查token有效性

请求url：http://localhost:9900/api-uaa/oauth/check_token?token={access_token}

请求方式：POST

### 登出逻辑说明logout

账户登出接口：`http://localhost:9900/api-uaa/oauth/remove/token?access_token={access_token}&redirect_uri={redirect_uri}`

请求方式：GET

请求参数：

| 参数名       | 是否必须 | 类型   | 说明                   |
| :----------- | :------- | :----- | :--------------------- |
| access_token | 是       | string | 登出的token            |
| redirect_uri | 否       | string | 登出成功后重定向的地址 |

前端请求：

```javascript
                            admin.req('api-uaa/oauth/check_token?token=' + accessToken, {}, function (data) {
                                if (data.active) {
                                    let loginPageUrl = window.location.protocol + '//' + window.location.host + '/login.html';
                                    window.location = djjConfig.base_server + 'api-uaa/oauth/remove/token?redirect_uri=' + loginPageUrl + '&access_token=' + accessToken;
                                } else {
                                    location.replace('login.html');
                                }
                            }, 'POST');
```
