# 缓存操作

## CacheManager集成

配置类展示：将应用到RedisAutoConfigure，实现缓存的配置。

```java
@Setter
@Getter
@ConfigurationProperties(prefix = "djj.cache-manager")
public class CacheManagerProperties {
    private List<CacheConfig> configs;

    @Setter
    @Getter
    public static class CacheConfig {
        /**
         * cache key
         */
        private String key;
        /**
         * 过期时间，second
         */
        private long second = 60;
    }
}
```

主要功能实现：

- 自定义添加配置
- 设置过期时间，如果不配置就永久不过期，过期单位为second秒，例如：

```yml
  cache-manager:
    configs:
      - key: menu
        secnod: 300
      - key: user
        second: 3600
```



具体使用方式：通过Spring 缓存注解：

```
//在方法或者类上加上以下注解
@Cacheable //判断缓存没有就执行方法更新缓存，缓存有就直接返回缓存的值
@CachePut //标记每次都更新缓存
@CacheEvict //标记删除缓存
```

## Spring缓存

### 介绍

Spring 提供了几个注解来支持Spring Cache，其核心主要是@Cacheable和@CacheEvict。

1. 使用@Cacheable标记的方法在执行后Spring Cache将会缓存结果。
2. 使用@CacheEvict标记的方法会在方法执行前或执行后移除Spring Cache中的某些元素。

### @Cacheable

@Cacheable 注解在方法上，表示该方法的返回结果是可以缓存的。也就是说，该方法的返回结果会放在缓存中，以便于以后使用相同的参数调用该方法时，会返回缓存中的值，而不会实际执行该方法。

**注意，这里强调了一点：参数相同。**这一点应该是很容易理解的，因为缓存不关心方法的执行逻辑，它能确定的是：对于同一个方法，如果参数相同，那么返回结果也是相同的。但是如果参数不同，缓存只能假设结果是不同的，所以对于同一个方法，你的程序运行过程中，使用了多少种参数组合调用过该方法，理论上就会生成多少个缓存的 key（当然，这些组合的参数指的是与生成 key 相关的）。

- value属性指定Cache名称
- key属性置顶自定义的key

具体参考：https://www.cnblogs.com/coding-one/p/12401630.html

### 使用案例

查询用户时：

```java
    @GetMapping(value = "/users/name/{username}")
    @ApiOperation(value = "根据用户名查询用户实体")
    @Cacheable(value = "user", key = "#username")
    public SysUser selectByUsername(@PathVariable("username") String username) {
        return sysUserService.selectByUsername(username);
    }
```

将返回值以key-value形式缓存：{username}:{user}

当发生用户修改的时候：

```java
    @PostMapping(value = "/users/saveOrUpdate")
    @ApiOperation("新增或更新用户")
    @AuditLog(operation = "'新增或更新用户:' + #sysUser.username")
    @CacheEvict(value = "user", key = "#sysUser.username")
    public CommonResult saveOrUpdate(@RequestBody SysUser sysUser) throws Exception {
        if (sysUserService.checkIsAdmin(sysUser.getId())) {
            return CommonResult.failed("ADMIN用户不可修改");
        }
        return sysUserService.saveOrUpdateUser(sysUser);
    }

```

驱逐已保存的key，保证数据的一致性。

## 缓存逻辑

### 获取操作：

1. 先查库
2. 不为空，则写入缓存

### 插入操作：

**细粒度分布式锁+select+insert**

先加一个细粒度的分布式锁，然后select查一下是否存在，不存在再进行insert

- 优点：性能影响较少，使用的是细粒度锁，所以只有重复提交记录才会阻塞
- 缺点：写操作会增加一次select开销，实现难度相对较大因为需要分布式细粒度锁

```java
    @Override
    public boolean saveIdempotency(T entity, DistributedLock locker, String lockKey,
                                   Wrapper<T> countWrapper, String msg) throws Exception {
        if (locker == null) {
            throw new LockException("DistributedLock is null");
        }
        if (StrUtil.isEmpty(lockKey)) {
            throw new LockException("lockKey is null");
        }
        try (
            DLock lock = locker.tryLock(lockKey, CommonConstants.DEFAULT_WAIT_TIME,
                CommonConstants.DEFAULT_LEASE_TIME, TimeUnit.SECONDS);
        ) {
            if (lock != null) {
                int count = super.count(countWrapper);
                if (count == 0) {
                    return super.save(entity);
                } else {
                    if (StrUtil.isEmpty(msg)) {
                        msg = "已存在";
                    }
                    throw new IdempotencyException(msg);
                }
            } else {
                throw new LockException("锁等待超时");
            }
        }
    }
```

### 更新操作：

**细粒度分布式锁+select+update**

```java
    @Override
    public boolean saveOrUpdateIdempotency(T entity, DistributedLock lock, String lockKey,
                                           Wrapper<T> countWrapper, String msg) throws Exception {
        if (entity != null) {
            TableInfo tableInfo = TableInfoHelper.getTableInfo(entity.getClass());
            if (tableInfo != null && StrUtil.isNotEmpty(tableInfo.getKeyProperty())) {
                Object idVal = ReflectionKit.getFieldValue(entity, tableInfo.getKeyProperty());
                if (StringUtils.checkValNull(idVal) ||
                    Objects.isNull(getById((Serializable) idVal))) {
                    if (StrUtil.isEmpty(msg)) {
                        msg = "已存在";
                    }
                    return this.saveIdempotency(entity, lock, lockKey, countWrapper, msg);
                } else {
                    return updateById(entity);
                }
            } else {
                throw ExceptionUtils.mpe("Error:  Can not execute. Could not find @TableId.");
            }
        }
        return false;
    }
```



### 删除操作：

1. 先删除库
2. 删除缓存